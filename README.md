# go-clean-arch project with AWS Lambda and AWS API Gateway
This is a serverless go program which implements the clean architecture and integrates with AWS Lambda, API Gateway, and DynamoDB.

## Prerequisites
### Install manually before start
#### npm
npm is required by serverless framework, and also it is easy to use scripts in package.json to build & deploy our service.
[Downloading and installing Node.js and npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

#### aws-cli
aws-cli is required to debug your program in local and deploy your personal online env from local.
[Getting started with the AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)

It is recommended to [enable multi-factor authentication (MFA)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa.html), and there is a script `aws_token_generator.sh` in `scripts` folder to help issue session-token.

#### go
[Tutorial: Get started with Go](https://go.dev/doc/tutorial/getting-started)

#### vscode
It's FREE!

**`Required plugins:`**
- Go, which is provided by Go Team at Google. It is required to develop go programs in vscode

**`Suggested plugins:`**
- GoComment, which is provided by lijunawk. It helps generate comments for functions and structs
- docs-yaml, which is provided by Microsoft. It helps format serverless.yml in vscode

#### serverless
Serverless Framework is easy for starup to understand the architecture of services and also it support not only AWS but also Google Cloud Platform and Microsoft Azure.
Install Serverless Framework by npm: `npm install -g serverless`.
Or you can directly run `npm install` under this project root folder, Serverless Framework will be installed in pre-install stage.
[Serverless.yml Reference](https://www.serverless.com/framework/docs/providers/aws/guide/serverless.yml)

#### Docker Desktop
Docker Desktop provides many docker images help running code in required env, which saves a lot of time to configure the env.
In this project, a docker image is used for running dynnamodb-local for dynamodb integration test.
[Docker Desktop](https://www.docker.com/)

### Handled by npm
#### golangci-lint
`golangci-lint` is a fast Go linters runner. It runs linters in parallel, uses caching, supports yaml config, has integrations with all major IDE and has dozens of linters included.
`golangci-lint` version: 1.48.0
Run `npm install` under this project root folder, `golangci-lint` will be installed in pre-install stage.
[golangci-lint GitHub](https://github.com/golangci/golangci-lint)
[golangci-lint Guide](https://freshman.tech/linting-golang)

#### swaggo
`swaggo` converts Go annotations to Swagger Documentation 2.0, which helps generate OpenAPI v2 spec to display in Swagger UI.
Run `npm install` under this project root folder, `swaggo` will be installed in pre-install stage.
[swaggo GitHub](https://github.com/swaggo/swag)
Another famouse tool to generate OpenAPI v2 spec from go source code: `go-swagger`. `swaggo` is selected because `swaggo` is more simpler, and personally I don't like the way of `go-swagger` to link a param object(struct).
[go-swagger GitHub](https://github.com/go-swagger/go-swagger)
And here is a blog compares those 2 tools,
[Generate swagger specification from Go source code](https://medium.com/@pedram.esmaeeli/generate-swagger-specification-from-go-source-code-648615f7b9d9)

## Project structure
Consider implementing `golang-standard` and the `clean architecture` in lambda based progoram (which always serves functions), the project is organized as:
```
project 
├── api 
|    ├── openapi/v2/swagger.json # openapi v2 spec
|    └── swagger-ui # swagger-ui static website
├── cmd 
|    ├── dummy/api/... # microservices
|    |    └── main.go # lambda handler, use mux proxy provide by aws
|    └── local
|         └── main.go # help run & debug local
├── configs 
|    └── env.yaml # env variable config file for all stage
├── deployment 
|    ├── db
|    |    └── serverless.yml # serverless to deploy db
|    ├── serverless.yml # serverless to deploy lambda, apigateway and so on
|    ├── output # folder generated by build script in package.json. gitignore it
|    └── *.zip # file generated by package script in package.json. gitignore it
├── internal # clean architecture
|    ├── app
|    |    ├── app.go # init beans
|    |    └── app_config.go # handle configs
|    ├── controller # handle http requests by mux
|    |    ├── api
|    |    |    ├── *_controller # entrance of apis
|    |    |    └── swaggo.go # entrance of swaggo generation
|    |    ├── *_controller.go # entrance of microservices
|    |    ├── controller.go # interface
|    |    ├── mux_controller.go # mux implementatation of controller.go
|    |    ├── mux_middlewares.go # implement necessary mux middlewares(also known as interseptors/filters)
|    |    └── mux_router.go # helper function to init mux router
|    ├── domain
|    |    └── dummy.go # entity and repository interface
|    ├── repository
|    |    ├── dummy_dynamodb_repo.go # dynamodb implementation of dummy repository
|    |    └── *_test.go # db integration test
|    ├── usecase
|    |    ├── dummy_usecase.go # biz logic of dummy
|    |    └── *_test.go # unit test
|    └── logger
|         └── logger.go # logger utils
├── scripts # helper scripts
├── test # test configs
├── .gitignore
├── .golangci.yml # lint configurations
├── go.mod
├── go.sum
├── package.json
├── package-lock.json
└── README.md
```
## Build the existing project
Run cmd `go mod tidy` to install all required packages.

## Lint
Run cmd `golangci-lint run` to format files and found potential problems.

## Test in local
### Check env.yml

**`Required`**
- change the `VARIANT`. `VARIANT` helps deploy your own aws services online for each stage. For example, name of official lambda of `dev` stage begins as `dev--{appcode}-`, while the name of your personal lambda of `dev` stage begins as `dev-{variant}-{appcode}-`.
- input the `ACCOUNT_ID`. ID of AWS Account you are using.
- change the `AWS_PROFILE` if you have a specific profile. remove it if you do not have the specific profile.

**`Optional`**
- change the `APPCODE` as you want.
- change the `REGION` and `AWS_REGION` to the one you want deploy resources to. 
- change the `AWS_DEPLOYMENT_BUCKET` as you want.
- change the `DUMMY_TABLE_NAME` in format `{stage}-{appcode}-dummy`.

### Before testing
When debuging from local without localstack, aws services should be prepared in advance except API Gateway & Lambda, such as DynamoDB, so it is necessary to deploy DynamoDB by Serverless Framework before testing.
refs `Deployment#Deploy Serverless services#Deploy DynamoDB service`

### Run local main and test
- run cmd `go run ./cmd/local/main.go` under `go-clean-arch-lambda-api`
- test `get`/`post`/`delete` dummy api by Postman or the other tools

### Run unit tests and integration tests
- start Docker Desktop
- run cmd `go test ./...` to execute unit tests
- run cmd `go test ./... -tags integration` to execute use case level unit tests and database level integration tests

### Test Swagger specification
- test Swagger specification locally
  - run cmd `npm run swag` to generate swagger spec
  - copy json in generated spec file
  - open `go-clean-arch-lambda-api/api/swagger-ui/swagger-spec.js` and set the value to `localSpec`
  - directly open `go-clean-arch-lambda-api/api/swagger-ui/index.html` to check the new spec

## Deployment
### Build and package by npm
- For Windows, it is necessary to to set go env `GOARCH` as `amd64`, `GOOS` as `linux`, because the online lambda runtime is based on linux core. check go environment variables by `go env`. 
  - [How to cross compile from Windows to Linux - stackoverflow](https://stackoverflow.com/questions/20829155/how-to-cross-compile-from-windows-to-linux)
  - [How to use environment variables in NPM](https://blog.jimmydc.com/cross-env-for-environment-variables/)
- open folder: `go-clean-arch-lambda-api`
  - install cmd tools by npm for cross-platform
  - run cmd `npm install` to install required tools automatically or install one by one if you prefer:
    - run cmd `npm install copyfiles --save-dev`
    - run cmd `npm install rimraf --save-dev`
    - run cmd `npm install cross-zip-cli --save-dev`
  - check `scripts` in `package.json`. and please edit the scripts according to your own env if necessary
  - run cmd `npm run lint`
  - run cmd `npm run test`
  - run cmd `npm run build:lambda`
  - run cmd `npm run package:lambda`
  - check `deployment/outout` folder, the `configs` folder is copied & pasted, and go executable files are generated
  - check `deployment` fodler, the zip files are generated


### Deploy Serverless services
#### Deploy DynamoDB service
Serverless Framework doesn't support well on skipping resources, and one solution to avoid unnecessary DynamoDB deployment is: add DynamoDB as an serverless service.
[Reason to create dynamodb tables as a service](https://stackoverflow.com/questions/41620437/how-to-continue-deploy-if-dynamodb-table-already-exists)

- Add a DynamoDB Serverless service
  - check `serverless.yml` in `go-clean-arch-lambda-api/deployment/db`
  - Or you can create a new one:
    - open folder: `go-clean-arch-lambda-api/deployment/db`
    - check [serverless example file](https://github.com/serverless/examples/blob/v3/aws-golang-rest-api-with-dynamodb/serverless.yml)
    - add a serverless service for dynamodb
    - use variables defined in `go-clean-arch-lambda-api/configs` to create dynamodb serverless resource. check `deployment/db/serverless.yml` for detail
- Deploy the created DynamoDB Serverless service
  - open root folder
  - make sure the required plugins are installed
    - should be installed by `npm install`
    - if not installed, run cmd `npm install serverless-deployment-bucket --save-dev`
  - run cmd `npm run build:db`
  - run cmd `npm run package:db`
  - run cmd `npm run deploy:db`
  - if you have a aws profile, change deploy cmd in `package.json` as 
  ```
  "deploy:db": "cd deployment/db && sls deploy --aws-profile {your profile name}"
  ````

#### Deploy Lambda and API Gateway
- serverless framework read the aws account and your aws credentials from your local credentials file, so make sure your credentials are valid. [Configuration and credential file settings](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)
- make sure `build` and `package` is done
- open folder: `go-clean-arch-lambda-api`
  - if you want use a specific local AWS profile to deploy, change deploy scripts in `package.json` like
   ```
  "scripts": {
    ...,
    "deploy:lambda": "cd deployment && sls deploy --force --aws-profile {profile_name}",
    "undeploy:lambda": "cd deployment && sls remove --aws-profile {profile_name}",
    ...
  },
  ```
  - run cmd `npm run deploy:lambda`

## Test on AWS
### Run and check log
**`Invoke URL`**
Open API Gateway service on AWS Console, and find the deployed API Gateway by region and name `{stage}-{variant}-go-clean-lambda` (which are set in serverless.yml).
Find url of your API Gateway, and try to invoke:
- run cmd `npm install curl -g`
- run cmd `curl {api_gateway_invoke_url}/api/dummy/1` and check the result
- run cmd `curl -X POST "{api_gateway_invoke_url}/api/dummy?id=1&name=aaa&attr=ttt"`
- run cmd `curl {api_gateway_invoke_url}/api/dummy/1` and check the result
- run cmd `curl -X DELETE {api_gateway_invoke_url}/api/dummy/1`
- run cmd `curl {api_gateway_invoke_url}/api/dummy/1` and check the result

**`Check Lambda Log`**
Open Lambda service on AWS Console, and find the deployed Lambda function by region and name `{stage}-{variant}-go-clean-lambda-dummy` (which are set in serverless.yml).
Switch to `Monitor` tab and open `Cloudwatch` to check the runtime log.

### Invoked AWS services
- API Gateway, trigger of Lambda
- Lambda, function to run the go program
- DynamoDB, db
- Cloudwatch, logs
- IAM, policies and roles to run Lambda
- S3, deployment bucket, where zips are uploaded
- CloudFormation, deployment stack, which manages deployed resources of each serverless service. Here are 2 stacks in the project, one for db, one for lambda-api.

## Reference
### Standard Go Project Layout
[Standard Go Project Layout](https://github.com/golang-standards/project-layout)
```
project
├── api
├── assets
├── build
├── cmd
├── configs
├── deployments
├── docs
├── examples
├── githooks
├── init
├── internal
├── pkg
├── scripts
├── test
├── third_party
├── tools
├── vendor
├── web
└── website
```
### The Clean Code Blog
[The Clean Code Blog](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg">

### Go linters
[golangci-lint](https://golangci-lint.run/) is a Go linters aggregator, which contains a lot of popular linters.

### Test in Golang
#### Naming conventions
Test names should include Action(what function), Condition(what param), and Expectation(what return).
[Naming standards for unit tests](https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html)
#### Separate integration tests from unit tests 
Use a build tag to seperate integration tests from unit tests for different kinds of test scenarios.
[Separate Your Go Tests with Build Tags](https://mickey.dev/posts/go-build-tags-testing/)

## Appendix
### Create new projects 
#### Create the npm project
Run cmd `npm init` to create the `package.json`. For example:
```
> npm init
package name: (go-clean-arch-lambda-api)
version: (1.0.0) 0.0.1
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
```

#### Create the go project
Run cmd to init a new module, such as `go mod init local.com/go-clean-lambda`.
Create `golang-standard` structure like:
```
project  
├── cmd 
├── configs 
├── deployment 
├── internal 
├── scripts
├── test
└── README.md
```
Write internal code follow the `clean architecture`. Example:
```
project 
├── cmd 
|    └── main.go # lambda handler
├── configs
├── deployment # serverless.yml
├── internal # clean architecture
|    ├── app
|    ├── controller
|    ├── domain
|    ├── repository
|    ├── usecase
|    └── utils
├── scripts
├── test
├── .gitignore
├── go.mod
├── go.sum
├── package.json
├── package-lock.json
└── README.md
```
Write your own code in each layter and run cmd `go get xxxx` to install a new package when necessary.

#### Add scripts to lint, test, build, packge, and deploy the program
For Windows, setting go env `GOARCH` as `amd64`, `GOOS` as `linux` before build the executable files, because the online lambda runtime is based on linux core. check go environment variables by `go env`. 
- [How to cross compile from Windows to Linux - stackoverflow](https://stackoverflow.com/questions/20829155/how-to-cross-compile-from-windows-to-linux)
- [How to use environment variables in NPM](https://blog.jimmydc.com/cross-env-for-environment-variables/)

Add scripts in `package.json` for automation:
```
  "scripts": {
    "preinstall": "...", // install necessary external tools, such as serverless framework and linters
    "prebuild": "...", // clear build output and copy necessary data to output folder
    "build": "...", // build go executable file
    "package": "...", // build zip file
    "deploy": "...", // deploy to aws by serverless framework
    "undeploy": "...", // destroy current stack
    "test": "...", // test go
    "lint": "..." // run linters
    ... // any other required scripts
  },
```
