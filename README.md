# go-clean-arch project with AWS Lambda and AWS API Gateway
This is a serverless go program which implements the clean architecture and integrates with AWS Lambda, API Gateway, and DynamoDB.

## Prerequisites
### Install manually before start
#### npm
npm is required by serverless framework, and also it is easy to use scripts in package.json to build & deploy our service.

[Downloading and installing Node.js and npm](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm)

#### aws-cli
aws-cli is required to debug your program in local and deploy your personal online env from local.

[Getting started with the AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-started.html)

It is recommended to [enable multi-factor authentication (MFA)](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa.html), and there is a script `aws_token_generator.sh` in `scripts` folder to help issue session-token.

#### go
[Tutorial: Get started with Go](https://go.dev/doc/tutorial/getting-started)

#### vscode
It's FREE!

**`Required plugins:`**
- Go, which is provided by Go Team at Google. It is required to develop go programs in vscode

**`Suggested plugins:`**
- GoComment, which is provided by lijunawk. It helps generate comments for functions and structs
- docs-yaml, which is provided by Microsoft. It helps format serverless.yml in vscode

#### serverless
Serverless Framework is easy for starup to understand the architecture of services and also it support not only AWS but also Google Cloud Platform and Microsoft Azure.
Install Serverless Framework by npm: `npm install -g serverless`.
Or you can directly run `npm install` under this project root folder, Serverless Framework will be installed in pre-install stage.
[Serverless.yml Reference](https://www.serverless.com/framework/docs/providers/aws/guide/serverless.yml)

#### Docker Desktop
Docker Desktop provides many docker images help running code in required env, which saves a lot of time to configure the env.
In this project, a docker image is used for running dynnamodb-local for dynamodb integration test.
[Docker Desktop](https://www.docker.com/)

#### Git Bash for Windows
Git Bash implements cp/rm/ssh-keygen/... commands inside.

### Handled by npm
#### golangci-lint
`golangci-lint` is a fast Go linters runner. It runs linters in parallel, uses caching, supports yaml config, has integrations with all major IDE and has dozens of linters included.
`golangci-lint` version: 1.48.0
Run `npm install` under this project root folder, `golangci-lint` will be installed in pre-install stage.
[golangci-lint GitHub](https://github.com/golangci/golangci-lint)
[golangci-lint Guide](https://freshman.tech/linting-golang)

#### swaggo
`swaggo` converts Go annotations to Swagger Documentation 2.0, which helps generate OpenAPI v2 spec to display in Swagger UI.
Run `npm install` under this project root folder, `swaggo` will be installed in pre-install stage.
[swaggo GitHub](https://github.com/swaggo/swag)
Another famouse tool to generate OpenAPI v2 spec from go source code: `go-swagger`. `swaggo` is selected because `swaggo` is more simpler, and personally I don't like the way of `go-swagger` to link a param object(struct).
[go-swagger GitHub](https://github.com/go-swagger/go-swagger)
And here is a blog compares those 2 tools,
[Generate swagger specification from Go source code](https://medium.com/@pedram.esmaeeli/generate-swagger-specification-from-go-source-code-648615f7b9d9)

## Project structure
Consider implementing `golang-standard` and the `clean architecture` in lambda based progoram (which always serves functions), the project is organized as:
```
project 
├── api 
|    ├── openapi/v2/swagger.json # openapi v2 spec
|    └── swagger-ui # swagger-ui static website
├── cmd 
|    ├── dummy/api/... # microservices
|    |    └── main.go # lambda handler, use mux proxy provide by aws
|    └── local
|         ├── env.yml # env variable for local stage
|         ├── jwt.rsa # private key for authentication jwt
|         ├── jwt.rsa.pub # public key for authentication jwt
|         └── main.go # help run & debug local
├── configs 
|    └── env.yaml # env variable config file for dev/eva/.. stage
├── deployment 
|    ├── api-doc
|    |    ├── configs # necessary configs for serverless.yml
|    |    ├── dist # api-doc static website dist. generated by script in package.json. gitignore it
|    |    └── serverless.yml # serverless to deploy api-doc
|    ├── db
|    |    ├── configs # necessary configs for serverless.yml
|    |    └── serverless.yml # serverless to deploy db
|    ├── lambda
|    |    ├── configs # necessary configs for serverless.yml
|    |    ├── *.zip # file generated by package script in package.json
|    |    └── serverless.yml # serverless to deploy lambda, apigateway and so on
|    └── plugins # serverless plugins to help cicd
├── internal # clean architecture
|    ├── app
|    |    ├── app.go # init beans
|    |    └── app_config.go # handle configs
|    ├── controller # handle http requests by mux
|    |    ├── api
|    |    |    ├── *_controller # entrance of apis
|    |    |    └── swaggo.go # entrance of swaggo generation
|    |    ├── *_controller.go # entrance of microservices
|    |    ├── controller.go # interface
|    |    ├── mux_controller.go # mux implementatation of controller.go
|    |    ├── mux_middlewares.go # implement necessary mux middlewares(also known as interseptors/filters)
|    |    └── mux_router.go # helper function to init mux router
|    ├── domain
|    |    └── dummy.go # entity and repository interface
|    ├── repository
|    |    ├── dummy_dynamodb_repo.go # dynamodb implementation of dummy repository
|    |    └── *_test.go # db integration test
|    ├── sdk # mock sdk provided by external services, with in-memory implementation
|    |    ├── account # mock sdk for users, 
|    |    ├── authentication # mock sdk for jwt based access control
|    |    └── authorization # mock sdk for role based access control
|    ├── usecase
|    |    ├── dummy_usecase.go # biz logic of dummy
|    |    └── *_test.go # unit test
|    └── logger
|         └── logger.go # logger utils
├── scripts # helper scripts
├── test # test configs
├── .gitignore
├── .golangci.yml # lint configurations
├── go.mod
├── go.sum
├── package.json
├── package-lock.json
└── README.md
```
## Build the existing project
Run cmd `go mod tidy` to install all required packages.

## Lint
Run cmd `golangci-lint run` to format files and found potential problems.

## Test in local
### Check env.yml for local

**`Required`**
- change the `VARIANT`. `VARIANT` helps deploy your own aws services online for each stage. For example, name of official lambda of `dev` stage begins as `dev--{appcode}-`, while the name of your personal lambda of `dev` stage begins as `dev-{variant}-{appcode}-`.
- input the `ACCOUNT_ID`. ID of AWS Account you are using.
- change the `AWS_PROFILE` if you have a specific profile. remove it if you do not have the specific profile.

**`Optional`**
- change the `APPCODE` as you want.
- change the `REGION` and `AWS_REGION` to the one you want deploy resources to. 
- change the `AWS_DEPLOYMENT_BUCKET` as you want.
- change the `DUMMY_TABLE_NAME` in format `{stage}-{appcode}-dummy` or `{stage}-{variant}-{appcode}-dummy`.

### Before testing
When debuging from local without localstack, aws services should be prepared in advance except API Gateway & Lambda, such as DynamoDB, so it is necessary to deploy DynamoDB by Serverless Framework before testing.
refs `Deployment#Deploy Serverless services#Deploy DynamoDB service`

### Run local main and test
- run cmd `go run ./cmd/local/main.go` under `go-clean-arch-lambda-api`
- test `get`/`post`/`delete` dummy api by Postman or the other tools

### Run unit tests and integration tests
- start Docker Desktop
- run cmd `go test ./...` to execute unit tests
- run cmd `go test ./... -tags integration` to execute use case level unit tests and database level integration tests

### Test Swagger specification
- test Swagger specification locally
  - run cmd `npm run swag` to generate swagger spec
  - copy json in generated spec file
  - open `go-clean-arch-lambda-api/api/swagger-ui/swagger-spec.js` and set the value to `localSpec`
  - directly open `go-clean-arch-lambda-api/api/swagger-ui/index.html` to check the new spec

## Deployment
### Check env.yml for deployment
Check variables before starting deployment like `Check env.yml for local`.

Do not change the value of `ACCOUNT_ID`. Serverless Framework will handle the real value of account id accordingly.

[Referencing AWS-specific variables](https://www.serverless.com/framework/docs/providers/aws/guide/variables#referencing-aws-specific-variables)

### Deploy Lambda Services
- For Windows, it is necessary to to set go env `GOARCH` as `amd64`, `GOOS` as `linux`, because the online lambda runtime is based on linux core. check go environment variables by `go env`. 
  - [How to cross compile from Windows to Linux - stackoverflow](https://stackoverflow.com/questions/20829155/how-to-cross-compile-from-windows-to-linux)
  - [How to use environment variables in NPM](https://blog.jimmydc.com/cross-env-for-environment-variables/)
- serverless framework read the aws account and your aws credentials from your local credentials file, so make sure your credentials are valid. 
  - [Configuration and credential file settings](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)
- open root folder
- run cmd to install cross-platform cmd tools and serverless plugins (already handled by `npm install`):
  - run cmd `npm install copyfiles --save-dev`
  - run cmd `npm install rimraf --save-dev`
  - run cmd `npm install cross-zip --save-dev`
  - run cmd `npm install serverless-deployment-bucket --save-dev`
- build, package, deploy steps
  - run cmd to lint code, such as `golangci-lint run`
  - run cmd to test go, such as `go test ./...`
  - run cmd to generate necessary configs and copy all configs to the deployment folder
  - run cmd to build go executable files, such as `go build -o {dest_folder}/main {source_main_folder}`
  - run cmd to zip the executable files as zips
  - run cmd `sls package` under `deployment/lambda` to check the generated `Cloudformation Templates`
  - run cmd `sls deploy` under `deployment/lambda` to deploy resources
- or run cmd `bash ./scripts/aws_codebuild_deploy.sh lambda` to handle everything of deploying lambda services
- refs `deploy_lambda` in `scripts/aws_codebuild_deploy.sh`, scripts in `package.json`, `serverless.yml` and invoked plugins in `deployment/plugins/*.js` for detail
- if you have a specific AWS profile, use `--aws-profile` option in the deploy cmd, such as
```
"scripts": {
  ...,
  "deploy:lambda": "cd deployment && sls deploy --force --aws-profile {profile_name}",
  "undeploy:lambda": "cd deployment && sls remove --aws-profile {profile_name}",
  ...
},
```

### Deploy DynamoDB service
Serverless Framework doesn't support well on skipping resources, and one solution to avoid unnecessary DynamoDB deployment is: add DynamoDB as an serverless service.
[Reason to create dynamodb tables as a service](https://stackoverflow.com/questions/41620437/how-to-continue-deploy-if-dynamodb-table-already-exists)

- Add a DynamoDB Serverless service
  - check `serverless.yml` in `go-clean-arch-lambda-api/deployment/db`
  - Or you can create a new one:
    - open folder: `go-clean-arch-lambda-api/deployment/db`
    - check [serverless example file](https://github.com/serverless/examples/blob/v3/aws-golang-rest-api-with-dynamodb/serverless.yml)
    - add a serverless service for dynamodb
    - use variables defined in `go-clean-arch-lambda-api/configs` to create dynamodb serverless resource. check `deployment/db/serverless.yml` for detail
- Deploy the created DynamoDB Serverless service
  - open root folder
  - run cmd to install cross-platform cmd tools and serverless plugins (already handled by `npm install`):
    - run cmd `npm install serverless-deployment-bucket --save-dev`
  - build, package, deploy steps
    - run cmd to copy necessary configs to deployment folder
    - run cmd `sls package` under `deployment/db` to check the generated `Cloudformation Templates`
    - run cmd `sls deploy` under `deployment/db` to deploy resources
  - or run cmd `bash ./scripts/aws_codebuild_deploy.sh db` to handle everything of deploying db service
  - refs `deploy_db` in `scripts/aws_codebuild_deploy.sh`, scripts in `package.json`, `serverless.yml` and invoked plugins in `deployment/plugins/*.js` for detail
  - if you have a specific AWS profile, add `--aws-profile` option in the deploy cmd, such as 
  ```
  "deploy:db": "cd deployment/db && sls deploy --aws-profile {your profile name}"
  ````

### Deploy API Documentation
AWS S3 provides a cheap and easy support to static websites, which matches the basic usage of Swagger UI - display API specifications - very much. 
Considering that the static website doesn't change frequently, it is not necessary to deploy the website itself everytime. Instead of deploying the whole api-doc everytime, uploading the generated swagger.json to S3 to update the API specification by CI/CD is much more efficient.

- Add a API Doc Serverless service
  - check `serverless.yml` in `go-clean-arch-lambda-api/deployment/api-doc`
  - Or you can create a new one:
    - open folder: `go-clean-arch-lambda-api/deployment/api-doc`
    - add a serverless service for API Doc
    - add a custom plugin to avoid deploying swagger-ui everytime
    - use variables defined in `go-clean-arch-lambda-api/configs` to create dynamodb serverless resource. check `deployment/db/serverless.yml` for detail
- Deploy the created API Doc Serverless service
  - open root folder
  - build, package, deploy steps
    - run cmd to generate swagger spec, such as `swag init -g {entrance}.go -pd -o {dest_folder} -ot json`
    - run cmd to copy necessary configs to deployment folder
    - run cmd to copy swagger spec and swagger-ui to deployment folder
    - run cmd `sls ${custom_plugin_cmd}` under `deployment/api-doc`
  - or run cmd `bash ./scripts/aws_codebuild_deploy.sh apidoc` to handle everything of deploying api documentation
  - refs `deploy_apidoc` in `scripts/aws_codebuild_deploy.sh`, scripts in `package.json`, `serverless.yml` and invoked plugins in `deployment/plugins/*.js` for detail
  - if you have a specific AWS profile, add `--aws-profile` option in the deploy cmd, such as 
  ```
  "deploy:apidoc": "cd deployment/api-doc && sls upload --aws-profile {your profile name}"
  ````
- Update Swagger specification from local manually
  - run cmd to generate swagger spec
  - directly upload the new swagger spec to S3 bucket


## Test on AWS
### Run and check log
**`Invoke URL`**
Open API Gateway service on AWS Console, and find the deployed API Gateway by region and name `{stage}-{variant}-go-clean-lambda` (which are set in serverless.yml).
Find url of your API Gateway, and try to invoke:
- run cmd `npm install curl -g`
- run cmd `curl {api_gateway_invoke_url}/api/dummy/1` and check the result
- run cmd `curl -X POST "{api_gateway_invoke_url}/api/dummy?id=1&name=aaa&attr=ttt"`
- run cmd `curl {api_gateway_invoke_url}/api/dummy/1` and check the result
- run cmd `curl -X DELETE {api_gateway_invoke_url}/api/dummy/1`
- run cmd `curl {api_gateway_invoke_url}/api/dummy/1` and check the result

**`Check Lambda Log`**
Open Lambda service on AWS Console, and find the deployed Lambda function by region and name `{stage}-{variant}-go-clean-lambda-dummy` (which are set in serverless.yml).
Switch to `Monitor` tab and open `Cloudwatch` to check the runtime log.

### Invoked AWS services
- API Gateway, trigger of Lambda
- Lambda, function to run the go program
- DynamoDB, db
- Cloudwatch, logs
- AWS Systems Manager Parameter Store, store keys
- IAM, policies and roles to run Lambda
- S3, deployment bucket(storage) and swagger-ui bucket(static web server)
- CloudFormation, deployment stack, which manages deployed resources of each serverless service. Here are 2 stacks in the project, one for db, one for lambda-api.

## Reference
### Standard Go Project Layout
[Standard Go Project Layout](https://github.com/golang-standards/project-layout)
```
project
├── api
├── assets
├── build
├── cmd
├── configs
├── deployments
├── docs
├── examples
├── githooks
├── init
├── internal
├── pkg
├── scripts
├── test
├── third_party
├── tools
├── vendor
├── web
└── website
```
### The Clean Code Blog
[The Clean Code Blog](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
<img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg">

### Go linters
[golangci-lint](https://golangci-lint.run/) is a Go linters aggregator, which contains a lot of popular linters.

### Test in Golang
#### Naming conventions
Test names should include Action(what function), Condition(what param), and Expectation(what return).
[Naming standards for unit tests](https://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html)
#### Separate integration tests from unit tests 
Use a build tag to seperate integration tests from unit tests for different kinds of test scenarios.
[Separate Your Go Tests with Build Tags](https://mickey.dev/posts/go-build-tags-testing/)

### Serverless Custom Plugin
#### Documentation
- [Creating custom plugins](https://www.serverless.com/framework/docs/guides/plugins/creating-plugins)
- [Custom scripts Guaide](https://github.com/serverless/serverless/blob/main/docs/guides/cicd/custom-scripts.md)
#### Examples
- [serverless-dotenv-plugin](https://github.com/neverendingqs/serverless-dotenv-plugin)
- [serverless-deployment-bucket](https://github.com/mikesouza/serverless-deployment-bucket)
- [serverless-go-build](https://github.com/sean9keenan/serverless-go-build/blob/master/index.js)


## Appendix
### Create new projects 
#### Create the npm project
Run cmd `npm init` to create the `package.json`. For example:
```
> npm init
package name: (go-clean-arch-lambda-api)
version: (1.0.0) 0.0.1
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
```

#### Create the go project
Run cmd to init a new module, such as `go mod init local.com/go-clean-lambda`.
Create `golang-standard` structure like:
```
project  
├── cmd 
├── configs 
├── deployment 
├── internal 
├── scripts
├── test
└── README.md
```
Write internal code follow the `clean architecture`. Example:
```
project 
├── cmd 
|    └── main.go # lambda handler
├── configs
├── deployment # serverless.yml
├── internal # clean architecture
|    ├── app
|    ├── controller
|    ├── domain
|    ├── repository
|    ├── usecase
|    └── utils
├── scripts
├── test
├── .gitignore
├── go.mod
├── go.sum
├── package.json
├── package-lock.json
└── README.md
```
Write your own code in each layter and run cmd `go get xxxx` to install a new package when necessary.

#### Add scripts to lint, test, build, packge, and deploy the program
For Windows, setting go env `GOARCH` as `amd64`, `GOOS` as `linux` before build the executable files, because the online lambda runtime is based on linux core. check go environment variables by `go env`. 
- [How to cross compile from Windows to Linux - stackoverflow](https://stackoverflow.com/questions/20829155/how-to-cross-compile-from-windows-to-linux)
- [How to use environment variables in NPM](https://blog.jimmydc.com/cross-env-for-environment-variables/)

Add scripts in `package.json` for automation:
```
  "scripts": {
    "preinstall": "...", // install necessary external tools, such as serverless framework and linters
    "prebuild": "...", // clear build output and copy necessary data to output folder
    "build": "...", // build go executable file
    "package": "...", // build zip file
    "deploy": "...", // deploy to aws by serverless framework
    "undeploy": "...", // destroy current stack
    "test": "...", // test go
    "lint": "..." // run linters
    ... // any other required scripts
  },
```
